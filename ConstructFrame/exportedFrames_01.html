<!DOCTYPE html>
 <!--  -->
<head>
	<title> ExportedFrames</title>
	<meta charset="utf-8" />
	<style> body { margin: 0; }	</style> 
</head>
<body> 	</body>
<script src="three.min.114.js"></script>
<script src="OrbitControls.114.js"></script>

<script>

// @author hofk

'use strict';
 
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.01, 1000 );
camera.position.set( 0, 1, 5 );
const renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0x000000, 1 );
const container = document.createElement( 'div' );
document.body.appendChild( container );
container.appendChild( renderer.domElement ); 

// lights 
const lightA0 = new THREE.AmbientLight( 0xffffff, 0.5 );
scene.add( lightA0 );
const lightA1 = new THREE.DirectionalLight();
lightA1.position.set(  2, 10, 5 );
scene.add( lightA1 );
const lightA2 = new THREE.DirectionalLight();
lightA2.position.set(  -2, 8, -4 );
scene.add( lightA2 );

const gridHelper = new THREE.GridHelper( 20, 20 );
scene.add( gridHelper );
 
const controls = new THREE.OrbitControls( camera, renderer.domElement );

let gFrame = []; // frames exported from ConstructFrame.html, increase the export ID there for every example

/*... BufferGeometry generated with ConstructFrame.html ...*/ 
gFrame[0] = new THREE.BufferGeometry();
gFrame[0].indices = new Uint32Array( [ 0, 6, 5, 0, 1, 6, 1, 7, 6, 1, 2, 7, 2, 8, 7, 2, 3, 8, 3, 9, 8, 3, 4, 9, 5, 11, 10, 5, 6, 11, 6, 12, 11, 6, 7, 12, 7, 13, 12, 7, 8, 13, 8, 14, 13, 8, 9, 14, 10, 16, 15, 10, 11, 16, 11, 17, 16, 11, 12, 17, 12, 18, 17, 12, 13, 18, 13, 19, 18, 13, 14, 19, 15, 21, 20, 15, 16, 21, 16, 22, 21, 16, 17, 22, 17, 23, 22, 17, 18, 23, 18, 24, 23, 18, 19, 24, 25, 1, 0, 25, 2, 1, 25, 3, 2, 25, 4, 3, 26, 20, 21, 26, 21, 22, 26, 22, 23, 26, 23, 24 ] );
gFrame[0].positions = new Float32Array( [ -0.89, -0.601, 0, -0.8, -0.601, -0.09, -0.73, -0.601, 0, -0.77, -0.601, 0.03, -0.8, -0.601, 0, -0.89, 0.989, 0, -0.8, 0.899, -0.09, -0.73, 0.829, 0, -0.77, 0.87, 0.03, -0.8, 0.899, 0, 0.489, 0.989, 0, 0.399, 0.899, -0.09, 0.329, 0.829, 0, 0.369, 0.87, 0.03, 0.399, 0.899, 0, 0.489, -0.09, 0, 0.399, 0, -0.09, 0.329, 0.07, 0, 0.369, 0.029, 0.03, 0.399, 0, 0, 0, -0.091, 0, 0, 0, -0.09, 0, 0.07, 0, 0, 0.029, 0.03, 0, 0, 0, -0.8, -0.601, 0, 0, 0, 0 ] );
gFrame[0].setIndex( new THREE.BufferAttribute( gFrame[0].indices, 1 ) );
gFrame[0].setAttribute( 'position', new THREE.BufferAttribute( gFrame[0].positions, 3 ) );
const gGrp = [ 0, 6, 0, 6, 6, 1, 12, 6, 2, 18, 6, 3, 24, 6, 0, 30, 6, 1, 36, 6, 2, 42, 6, 3, 48, 6, 0, 54, 6, 1, 60, 6, 2, 66, 6, 3, 72, 6, 0, 78, 6, 1, 84, 6, 2, 90, 6, 3, 96, 12, 4, 108, 12, 5 ];
for ( let f = 0, p = 0; f < 18; f ++, p += 3 ) { gFrame[0].addGroup( gGrp[ p ], gGrp[ p + 1 ], gGrp[ p + 2 ] ); }
gFrame[0].computeVertexNormals();

// frame material   rainbow-colors
 
const m0 = new THREE.MeshPhongMaterial( { color: 0xfa0001, side: THREE.DoubleSide } );
const m1 = new THREE.MeshPhongMaterial( { color: 0xff7b00, side: THREE.DoubleSide } );
const m2 = new THREE.MeshPhongMaterial( { color: 0xf9f901, side: THREE.DoubleSide } );
const m3 = new THREE.MeshPhongMaterial( { color: 0x008601, side: THREE.DoubleSide } );
const m4 = new THREE.MeshPhongMaterial( { color: 0x01bbbb, side: THREE.DoubleSide } );
const m5 = new THREE.MeshPhongMaterial( { color: 0x250290, side: THREE.DoubleSide } );
const m6 = new THREE.MeshPhongMaterial( { color: 0xfc4ea5, side: THREE.DoubleSide } );
const m7 = new THREE.MeshPhongMaterial( { color: 0x83058a, side: THREE.DoubleSide } );
const m8 = new THREE.MeshPhongMaterial( { color: 0x83058a, side: THREE.DoubleSide } );

const material = [ m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8, m0, m1, m2, m4, m5, m6, m7, m8 ];

let mesh = [];

for ( let i = 0; i < gFrame.length; i ++ ) {

	 mesh[ i ] = new THREE.Mesh( gFrame[ i ], material );
	
	scene.add( mesh[ i ] );
	
}	

animate();

function animate() {
	
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
	controls.update();
	
}

</script>

</html>